#Overkill RC
#by $authors
#Memory cell layout: [enabled, load, unitId, destX, destY, shootX, shootY, shouldFire, approachDistance, secondaryUnitId, healing]

print "$name by $authors"
print "Source code available at $githubUrl"
print "Movement module"
set minHealth 0.8
print "Rest of settings in micro proc"

set quickLoops 80
set $memcellpos.enabled 0
set $memcellpos.loading 1
set $memcellpos.unitId 2
set $memcellpos.destX 3
set $memcellpos.destY 4
set $memcellpos.shootX 5
set $memcellpos.shootY 6
set $memcellpos.shouldFire 7
set $memcellpos.approachDistance 8
set $memcellpos.secondaryUnitId 9
set $memcellpos.healing 10
set logicItemTakeRadius 5

restart:
jump restart equal sorter1 null
jump restart equal cell1 null
set bombingItemSorter sorter1
set cell cell1

init_read_cell:
	read enabled cell $memcellpos.enabled
	read loading cell $memcellpos.loading
	read unit.id cell $memcellpos.unitId
	lookup unit unitType unit.id
	read dest.x cell $memcellpos.destX
	read dest.y cell $memcellpos.destY
	read shoot.x cell $memcellpos.shootX
	read shoot.y cell $memcellpos.shootY
	read shouldFire cell $memcellpos.shouldFire
	read approachDistance cell $memcellpos.approachDistance
	read healing cell $memcellpos.healing
	sensor bombingItem bombingItemSorter @config
	jump init_read_cell equal enabled false

	ubind unitType
	sensor unit.range
	sensor unit.itemCapacity
	sensor unit.maxHealth
	ulocate building core false core.x core.y core.exists core

set i 0
send_commands_loop:
	bind_unit:
		ubind unitType
		sensor unit.flag
		jump bind_unit notEqual unit.flag 0
	jump load equal loading true
	jump heal equal healing true
	
	send_commands:
		ucontrol approach dest.x dest.y approachDistance
		ucontrol within shoot.x shoot.y unit.range target_position
		jump target_self equal target_position false

		target_position:
			ucontrol target shoot.x shoot.y shouldFire
			jump end_send_commands_loop
		target_self:
			ucontrol targetp @unit shouldFire
			jump end_send_commands_loop


	load:
		sensor unit.firstItem
		sensor unit.totalItems
		jump take_item equal unit.firstItem null
		jump drop_item notEqual unit.firstItem bombingItem
		jump take_item notEqual unit.totalItems unit.itemCapacity
		jump send_commands
	heal:
		sensor unit.health
		op div unit.healthPercentage unit.health unit.maxHealth
		jump send_commands greaterThan unit.healthPercentage minHealth #TODO: make var for healThreshold? idk
		ulocate building repair false healTurret.x healTurret.y isFound healTurret
		jump send_commands equal isFound false #remove this check eventually as the rc schem will have repair turret spam
		ucontrol move healTurret.x healTurret.y
		jump send_commands
	
	drop_item:
		ucontrol itemDrop core 9999
	take_item:
		ucontrol move core.x core.y
		ucontrol itemTake core bombingItem 9999
		jump end_send_commands_loop always

	end_send_commands_loop:
	op add i 1
	jump send_commands_loop lessThan i quickLoops




#I didnt have time to finish this, below code is repetitive and was for old memcell values





# 	set i 0
# 	ubind unitType
# 	sensor unit.range
# quick_loop:
# 	bind_unit:
# 		ubind unitType
# 		sensor unit.flag
# 		jump bind_unit notEqual unit.flag 0
# 	move:
# 		ucontrol approach x y approachDistance
# 	fire:
# 		ucontrol within x y unit.range target_position
# 		jump target_self equal target_position false
# 		target_position:
# 			ucontrol target x y shouldFire
# 		end_loop:
# 			op add i i 1
# 			jump quick_loop lessThan i quickLoops
# 			jump init_read_cell always
# 		target_self:
# 			ucontrol targetp @unit shouldFire
# 		end_loop_2:
# 			op add i i 1
# 			jump quick_loop lessThan i quickLoops
# 			jump init_read_cell always

# load_units:
# set i 0
# ubind unitType
# sensor unit.itemCapacity
# quick_loop_2:
# 	op add i 1
# 	ubind unitType
# 	should_take_or_drop:
# 		ulocate building core false core.x core.y core.exists core
# 		sensor unit.firstItem
# 		sensor unit.totalItems
# 		jump take_item equal unit.firstItem null
# 		jump drop_item notEqual unit.firstItem bombingItem
# 		jump take_item notEqual unit.totalItems unit.itemCapacity
# 	move_back:
# 		ucontrol approach x y approachDistance

# 		ucontrol within x y unit.range target_position
# 		jump target_self_2 equal target_position false
# 		target_position_2:
# 			ucontrol target x y shouldFire
# 			jump quick_loop_2 lessThan i quickLoops
# 			jump init_read_cell always
# 		target_self_2:
# 			ucontrol targetp @unit shouldFire
# 			jump quick_loop_2 lessThan i quickLoops
# 			jump init_read_cell always

# 		jump quick_loop_2 lessThan i quickLoops
# 		jump init_read_cell always
# 	drop_item:
# 		ucontrol itemDrop core 9999
# 	take_item:
# 		ucontrol move core.x core.y #this is a bit weird but it works
# 		ucontrol itemTake core bombingItem 9999
# 		jump quick_loop_2 lessThan i quickLoops
# 		jump init_read_cell always
