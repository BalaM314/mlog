#Overkill RC
#by $authors
#Memory cell layout: [enabled, load, unitId, destX, destY, shootX, shootY, shouldFire, approachDistance, secondaryUnitId, healing]

print "$name by $authors"
print "Source code available at $githubUrl"
print "Movement module"
set minHealth 0.8
print "Rest of settings in micro proc"

set logicItemTakeRadius 5
set quickLoops 80

#null check for schem blocks
restart:
jump restart equal sorter1 null
jump restart equal cell1 null
set bombingItemSorter sorter1
set cell cell1

#initialize mostly static vars
init_read_cell:
	read enabled cell $memcellpos.enabled
	read loading cell $memcellpos.loading
	read unit.id cell $memcellpos.unitId
	lookup unit unitType unit.id
	read dest.x cell $memcellpos.destX
	read dest.y cell $memcellpos.destY
	read shoot.x cell $memcellpos.shootX
	read shoot.y cell $memcellpos.shootY
	read shouldFire cell $memcellpos.shouldFire
	read approachDistance cell $memcellpos.approachDistance
	#todo read secondaryUnitId and use it
	read healing cell $memcellpos.healing
	sensor bombingItem bombingItemSorter @config
	jump init_read_cell equal enabled false

	ubind unitType
	sensor unit.range
	sensor unit.itemCapacity
	sensor unit.maxHealth
	ulocate building core false core.x core.y core.exists core

set i 0
send_commands_loop: #A loop to bind a ton of units and send commands to them, using the loaded config(x, y, etc).
	bind_unit:
		ubind unitType
		sensor unit.flag
		jump bind_unit notEqual unit.flag 0
	jump heal equal healing true
	healed:
	jump load equal loading true
	loaded:
	
	send_commands:
		ucontrol approach dest.x dest.y approachDistance
		ucontrol within shoot.x shoot.y unit.range target_position
		jump target_self equal target_position false

		target_position:
			sensor unit.x
			sensor unit.y
			op sub diffrence.x unit.x shoot.x #get diffrence
			op sub diffrence.y unit.y shoot.y
			op angle shoot.angle diffrence.x diffrence.y #normalization
			op cos shoot.x.normalized shoot.angle
			op sin shoot.y.normalized shoot.angle
			op mul shooting.x shoot.x.normalized unitRange #scale and position back
			op add shooting.x unit.x
			op mul shooting.y shoot.y.normalized unitRange
			op add shooting.y unit.y
			ucontrol target shooting.x shooting.y shouldFire
			jump end_send_commands_loop
		target_self:
			ucontrol targetp @unit shouldFire
			jump end_send_commands_loop


	load:
		sensor unit.firstItem
		sensor unit.totalItems
		jump take_item equal unit.firstItem null
		jump drop_item notEqual unit.firstItem bombingItem
		jump take_item notEqual unit.totalItems unit.itemCapacity
		jump loaded

	heal:
		sensor unit.health
		op div unit.healthPercentage unit.health unit.maxHealth
		jump healed greaterThan unit.healthPercentage minHealth
		ulocate building repair false healTurret.x healTurret.y isFound healTurret
		jump send_commands equal isFound false #remove this check eventually as the rc schem will have repair turret spam
		ucontrol move healTurret.x healTurret.y
		jump end_send_commands_loop
	
	#item control
	drop_item:
		ucontrol itemDrop core 9999
	take_item:
		ucontrol move core.x core.y
		ucontrol itemTake core bombingItem 9999
		jump end_send_commands_loop always

	end_send_commands_loop:
	op add i 1
	jump send_commands_loop lessThan i quickLoops